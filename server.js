const http = require('http');
const fs = require('fs/promises');
const path = require('path');
const { renderPage } = require('./renderer');
const { DB } = require('./db/queries');

// === –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã ===
const PORT = 8080;
const CACHE_DIR = path.resolve('./cache');
const DB_CONFIG = {
    host: 'localhost',
    user: 'shop_gpt',
    password: 'KY4$}LF}H*)naq?',
    database: 'shop_gpt',
    charset: 'utf8mb4'
};
const PRODUCTS_PER_PAGE = 10;
const dataBase = new DB(DB_CONFIG);

// === –û—Å–Ω–æ–≤–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã ===
const pageCache = new Map();       // { url: filePath }
const generationLocks = new Map(); // { url: Promise }

// === üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø—É—Ç–µ–π ===
function safeJoin(base, target) {
    const resolvedBase = path.resolve(base);
    const resolvedTarget = path.resolve(base, target);
    const relative = path.relative(resolvedBase, resolvedTarget);

    if (relative.startsWith('..') || path.isAbsolute(relative)) {
        throw new Error('Path traversal attempt detected');
    }

    return resolvedTarget;
}

// === –†–∞–±–æ—Ç–∞ —Å –∫—ç—à–µ–º ===

// –ß—Ç–µ–Ω–∏–µ HTML –∏–∑ –∫—ç—à–∞
async function getCachedPage(url) {
    const cachePath = pageCache.get(url);
    if (!cachePath) return null;
    try {
        return await fs.readFile(cachePath, 'utf8');
    } catch {
        deleteCachedPage(url)
        return null;
    }
}

// –ó–∞–ø–∏—Å—å HTML –≤ –∫—ç—à
async function writeCachedPage(url, html) {
    const fileName = url.replace(/[^\w]/g, '_') + '.html';
    try {
        const filePath = safeJoin(CACHE_DIR, fileName);
        await fs.mkdir(CACHE_DIR, { recursive: true });
        await fs.writeFile(filePath, html, 'utf8');
        pageCache.set(url, filePath);
    } catch (err) {
        console.error(`–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –∫—ç—à–∞ –¥–ª—è ${url}:`, err);
    }
}

// –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å –¥–∏—Å–∫–∞ –∏ Map
async function deleteCachedPage(url) {
    try {
        const filePath = pageCache.get(url);
        if (filePath) {
            await fs.unlink(filePath);
            pageCache.delete(url);
        }
    } catch (err) {
        console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞ ${filePath}:`, err);
    }
}

// === –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü ===
async function generatePage(url, dataProvider, templateName, statusCode = 200) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
    const cached = await getCachedPage(url);
    if (cached) return { html: cached, status: statusCode };

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–ª–æ–∫–∏—Ä–æ–≤–∫—É (—á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ race conditions)
    if (generationLocks.has(url)) {
        const result = await generationLocks.get(url);
        return result;
    }

    // –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    const promise = (async () => {
        try {
            const pageData = await dataProvider();
            const { data, ...opts } = (pageData && typeof pageData === 'object') ? pageData : {};

            const html = await renderPage(templateName, data, opts);
            await writeCachedPage(url, html);
            return { html, status: statusCode };
        } catch (err) {
            console.error(`–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã ${url}:`, err);
            const html = await renderPage(
                '500',
                {},
                {
                    title: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞',
                    url,
                    headerProps: { currentPath: url },
                    footerProps: { organizationName: '–£—á–µ–±–Ω—ã–π –º–∞–≥–∞–∑–∏–Ω' }
                }
            );
            return { html, status: 500 };
        }
    })();

    generationLocks.set(url, promise);
    promise.finally(() => generationLocks.delete(url));

    return await promise;
}

// === –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ HTML ===
function sendHtml(res, html, statusCode = 200) {
    res.writeHead(statusCode, { 'Content-Type': 'text/html; charset=utf-8' });
    res.end(html);
}

// === –ú–∞—Ä—à—Ä—É—Ç—ã ===
const routes = {
    '/catalog': async (req, res) => {
        const { html, status } = await generatePage(
            '/catalog',
            async () => ({
                title: '–ö–∞—Ç–∞–ª–æ–≥ —Ç–æ–≤–∞—Ä–æ–≤',
                description: '–ü—Ä–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞—à –∞—Å—Å–æ—Ä—Ç–∏–º–µ–Ω—Ç –ø—Ä–æ–¥—É–∫—Ü–∏–∏',
                data: {
                    products: await dataBase.getAllProducts({ limit: PRODUCTS_PER_PAGE, offset: 0 }),
                    subcategories: await dataBase.getRootCategories()
                },
                type: 'category'
            }),
            'catalog'
        );
        sendHtml(res, html, status);
    },

    '/': async (req, res) => {
        const { html, status } = await generatePage(
            '/',
            async () => ({
                title: '–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞',
                description: '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –Ω–∞—à –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-–º–∞–≥–∞–∑–∏–Ω!',
            }),
            'home'
        );
        sendHtml(res, html, status);
    },

    '/contacts': async (req, res) => {
        const { html, status } = await generatePage(
            '/contacts',
            async () => ({
                title: '–ö–æ–Ω—Ç–∞–∫—Ç—ã',
                description: '–°–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏ –ª—é–±—ã–º —É–¥–æ–±–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º',
            }),
            'contacts'
        );
        sendHtml(res, html, status);
    },

    '/404': async (req, res) => {
        const { html, status } = await generatePage(
            '/404',
            async () => ({
                title: '–°—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞',
                description: '–û—à–∏–±–∫–∞ 404: —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.',
                url: req.url
            }),
            '404',
            404
        );
        sendHtml(res, html, status);
    }
};

// === –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ —Ä–æ—É—Ç—ã ===
const dynamicRoutes = {
    'category': (category) => async (req, res) => {
        const { html, status } = await generatePage(
            `/catalog/${category.full_path}`,
            async () => ({
                title: `–ö–∞—Ç–µ–≥–æ—Ä–∏—è: ${category.name}`,
                description: `–¢–æ–≤–∞—Ä—ã –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ "${category.name}"`,
                data: {
                    products: await dataBase.getProductsByCategory(category, { limit: PRODUCTS_PER_PAGE, offset: 0 }),
                    subcategories: await dataBase.getSubcategories(category)
                },
                type: "category",
            }),
            'catalog'
        );
        sendHtml(res, html, status);
    },
    'product': (category, productSlug) => async (req, res) => {
        const product = await dataBase.getProduct(productSlug);
        if (!product.length) {
            return routes['/404'](req, res);
        }
        const { html, status } = await generatePage(
            `/catalog/${category.full_path}/${product[0].slug}`,
            async () => ({
                title: `–¢–æ–≤–∞—Ä: ${product[0].name}`,
                description: `–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–æ–≤–∞—Ä–µ "${product[0].name}" –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ "${category.name}"`,
                data: {
                    products: product
                }
            }),
            'catalog'
        );
        sendHtml(res, html, status);
    }
};

function getDynamicHandler(pathname) {
    const rel = pathname.replace(/^\/catalog\//, '');
    const segments = rel.split('/').filter(Boolean);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—è —Å —Ç–∞–∫–∏–º –ø–æ–ª–Ω—ã–º –ø—É—Ç—ë–º
    const catPath = segments.join('/');
    const category = dataBase.categoriesMap?.get(catPath);
    if (category) {
        return dynamicRoutes['category'](category);
    }

    // –ò–Ω–∞—á–µ, –≤–æ–∑–º–æ–∂–Ω–æ, —ç—Ç–æ —Ç–æ–≤–∞—Ä
    const productSlug = segments.pop();
    const parentPath = segments.join('/');
    const categoryParent = dataBase.categoriesMap?.get(parentPath);

    if (categoryParent) {
        return dynamicRoutes['product'](categoryParent, productSlug);
    }

    return null;
}


// === –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ ===
function setSecurityHeaders(res) {
    res.setHeader('Content-Security-Policy', [
        "default-src 'self'",
        "script-src 'self'",
        "style-src 'self'",
        "img-src 'self' data:",
        "font-src 'self'",
        "object-src 'none'",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "upgrade-insecure-requests"
    ].join('; '));

    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
    res.setHeader('Permissions-Policy', 'geolocation=(), camera=(), microphone=()');
    res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');
    res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');
}

// === –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç–∞—Ç–∏–∫–∏ ===
async function serveStatic(filePath, res) {
    try {
        const full = path.join(__dirname, filePath);
        const data = await fs.readFile(full);
        const ext = path.extname(full).toLowerCase();
        const types = {
            '.js': 'application/javascript; charset=utf-8',
            '.css': 'text/css; charset=utf-8',
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.svg': 'image/svg+xml',
            '.html': 'text/html; charset=utf-8'
        };
        res.writeHead(200, { 'Content-Type': types[ext] || 'application/octet-stream' });
        res.end(data);
    } catch (err) {
        console.error(err);
        res.writeHead(404, { 'Content-Type': 'text/plain; charset=utf-8' });
        res.end('Not found');
    }
}

async function startServer() {
    await dataBase.init();

    // === –û—Å–Ω–æ–≤–Ω–æ–π HTTP-—Å–µ—Ä–≤–µ—Ä ===
    http.createServer(async (req, res) => {
        try {
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞—â–∏—Ç–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
            setSecurityHeaders(res);

            const url = new URL(req.url.replaceAll(/\/{2,}/g, '/'), `http://${req.headers.host}`);
            const pathname = decodeURIComponent(url.pathname).match(/(.+?)\/?$/)[1];

            if (pathname.startsWith('/static/')) {
                await serveStatic(pathname, res);
            } else {
                const handler = routes[pathname] || getDynamicHandler(pathname) || routes['/404'];

                await handler(req, res);
            }
        } catch (err) {
            console.error('–û—à–∏–±–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ:', err);
            const html = await renderPage(
                '500',
                {},
                {
                    title: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞',
                    url: '/',
                    headerProps: { currentPath: '/' },
                    footerProps: { organizationName: '–£—á–µ–±–Ω—ã–π –º–∞–≥–∞–∑–∏–Ω' }
                }
            );
            sendHtml(res, html, 500);
        }
    }).listen(PORT, () => {
        console.log(`‚úÖ Server running on http://localhost:${PORT}`);
    });
}

startServer();